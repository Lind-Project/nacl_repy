Future API:
https://seattle.cs.washington.edu/wiki/FutureRepyAPI

gethostbyname(name)
getmyip()
sendmessage(destip, destport, message, localip, localport)
listenformessage(localip, localport)
openconnection(destip, destport, localip, localport, timeout)
listenforconnection(localip, localport)
openfile(filename, create)
file.close()
file.readat(sizelimit, offset)
file.writeat(data, offset)
listfiles()
removefile(filename)
exitall()
createlock()
lock.acquire(blocking)
lock.release()
getruntime()
randombytes()
createthread(function)
sleep(seconds)
socket.close()
socket.recv(numbytes)
socket.send(message)
tcpserversocket.getconnection()
tcpserversocket.close()
udpserversocket.getmessage()
udpserversocket.close()
getthreadname()
createvirtualnamespace(code, name)
virtualnamespace.evaluate(context)
getresources()
getlasterror()



To Finish:

recvmess(localip, localport, function)
sendmess(desthost, destport, message, localip=None, localport=None)
openconn(desthost, destport, localip=None, localport=0, timeout = 5)
waitforconn(localip, localport, function)
stopcomm(commhandle)


settimer(waittime, function, args)
canceltimer(timerhandle)
socket.close()
socket.recv(bytes)
socket.send(message)


Done:

gethostbyname_ex(name)
getmyip()
lock.acquire(blocking=1)
lock.release()
getruntime()
randomfloat()
getlock()
sleep(seconds)
listdir()
open(filename, mode='r')
file.close()
file.flush()
file.next()
file.read(size)
file.readline(size)
file.readlines(size)
file.seek(offset, whence=0)
file.write(data)
file.writelines(lines)
exitall()
removefile(filename)



Notes:
- Somewhere a fork is happening. I have to catch and destroy and extra child process.
- blocking does not respond to ctrl-C
- We should talk about error handeling.
- python provides its own mallocs? should we use?
- file i/o has to be memcpyd to avoid GC
- readlines is skipped, memory implementation is complex. Who frees?
