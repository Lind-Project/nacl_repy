"""
The Lind OS Server.  This module services system calls coming from glibc
<Author>
  Chris Matthews (cmatthew@cs.uvic.ca)
<Start Date>
  Dececmber 2010
"""

include struct.repy           

# if you comment this include out the line numbers are
# correct for syntax errors.
 

SYSCALL="syscall"               # shortcut to syscall dict items
FILES="FILES"                   # these also make a typo more specific
                                # than a dict lookup error
SUCCESS=0


PRODUCTION=False

def unimplemented(who):
  """what to do when we come across some code that needs to be finished.
  For now, lets just keep running, but really this should not happen
  so we should exit.  """
  message =  "a unimplemented function has been called " + str(who)
  if PRODUCTION:
    print "error: ", message
    exitall()
  else:
    print "warning: ", message


class Response:
  """ An Response to a RPC request.

  <Purpose>

  This object is responsible sending responses to specific system calls.  It is
  loaded with data, then can build a reply struct which can then be sent back to
  NaCl through an IMC channel.

  The Response can be in one of two states, an Error response (for calls that
  have failed somehow), or a success response. An error response has an error
  code and a message for perror to display. A success has a return code and
  optionally a data string.

  TODO: error message is not yet displayed by perror.
  """
  message = "No error message set"
  data = ""

  def __init__(self, response_type,  is_error, return_code):
    assert isinstance(response_type, str), "response type is not a string"
    self.response_type = response_type
    assert isinstance(is_error, bool), "is error is not a boolean"
    self.is_error = is_error
    
    if isinstance(return_code, str):
      try:
        self.return_code =  mycontext["errno.h"][return_code]
      except KeyError:
        raise Exception("Return code is not a valid error number.")
    elif isinstance(return_code, int):
      self.return_code = return_code
    else:
      raise Exception("Invalid return code.")
    assert isinstance(self.return_code, int), "return code is not a int, or a stirng which mapped to an int"

  def make_struct(self):
    """
    <Purpose>

    Get the representation of this Response in struct format.  A struct is a
    string, which when sent to C can be cast as a struct and used nativly.
    The struct format is iiii123s, wich is:
    struct {
        int message_len;
        int magic_number;
        int is_in_error;
        int return_or_error_code;
        char data_or_message[];
    };

    """
    reply = None
    if self.is_error:
      # message format <is_error, code, message>
      reply = struct_pack("<i<i<i<i" + str(len(self.message)) + "s", len(self.message) + 12, 101010, 1, self.return_code, self.message)
    else:
      # message format <is_error, code, data>
      reply = struct_pack("<i<i<i<i" + str(len(self.data)) + "s", len(self.data) + 12, 101010, 0, self.return_code, self.data)
    return reply

  def __str__(self):
    """Human readable format for debugging"""
    if self.is_error:
      type_str = "Error"
    else:
      type_str = "Success"
    return type_str + " in " + self.response_type + " with code " + str(self.return_code) + " with data of size " + str(len(self.data)) + " with data " + str(self.data)

def ErrorResponseBuilder(who ,code, message):
  """ Build an error response object.

  <Arguments>
   who: Which portion of the system or system call is making this reply.
   code: Positive error code to return, or string from errno.h to resolve to a number.
   message: A detailed message about the error.
   """
  r = Response(who, True, code)
  r.message = message
  return r

def SuccessResponseBuilder(who, code, data=None):
  """Build an success response object.

  <Arugments>
     who: Which portion of the system or system call is making this reply.
     code: the integer return code to return.
     data: the data this call returns (as a string), if any.
  """
  r =  Response(who, False, code)
  if data!=None:
    r.data = data
  return r


def lind_fs_access(args):
  """
  NAME
       access - check real user's permissions for a file

  SYNOPSIS
       #include <unistd.h>

       int access(const char *pathname, int mode);

   DESCRIPTION
       access() checks whether the calling process can access the file pathname.
       If pathname is a symbolic link, it is dereferenced.

       The mode specifies the accessibility check(s) to be performed, and is
       either the value F_OK, or a mask consisting of the bitwise OR of one or
       file exists and grants read, write, and execute permissions,
       respectively.

       The check is done using the calling process's real UID and GID, rather
       than the effective IDs as is done when actually attempting an operation
       (e.g., open(2)) on the file.  This allows set-user-ID programs to easily
       determine the invoking user's author‚Äê ity.

       If the calling process is privileged (i.e., its real UID is zero), then
       an X_OK check is successful for a regular file if execute permission is
       enabled for any of the file owner, group, or other.

  RETURN VALUE
       On success (all requested permissions granted), zero is returned.  On
       error (at least one bit in mode asked for a permission that is denied, or
       some other error occurred), -1 is returned, and errno is set
       appropriately.

  ERRORS
       access() shall fail if:

       EACCES The requested access would be denied to the file, or search
       permission is denied for one of the directories in the path prefix of
       pathname.  (See also path_resolution(7).)

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling symbolic link.

       ENOTDIR A component used as a directory in pathname is not, in fact, a
              directory.

       EROFS Write permission was requested for a file on a read-only file
       system.

       access() may fail if:

       EFAULT pathname points outside your accessible address space.

       EINVAL mode was incorrectly specified.

       EIO    An I/O error occurred.

       ENOMEM Insufficient kernel memory was available.

       ETXTBSY Write access was requested to an executable which is being
              executed.
  """
  log("Calling Access")
  #TODO(cmatthew): implement basic checking
  unimplemented("access")
  return ErrorResponseBuilder("fs_access", "ENOSYS", "access system call is not implemented." )

class File:
  def __init__(self, name, fobj):
    self.name = name
    self.handle = -1
    self.fobj = fobj
    self.location = 0

class FileList:
  def __init__(self):
    self.list = []

  def insert(self, file_obj):
    assert isinstance(file_obj, File)
    self.list.append(file_obj)
    file_handle = self.list.index(file_obj)
    file_obj.handle = file_handle
    return file_handle

  def insertFile(self, file_name, fobj):
     f = File(file_name, fobj)
     return self.insert(f)


  def lookup(self, handle):
    return self.list[handle]

  def lookupName(self, name):
    for fobjs in self.list:
      if fobjs.name == name:
        return fobjs.handle
    return 0


def lind_fs_open(args):
  """int open(const char *pathname, int flags);
  int open(const char *pathname, int flags, mode_t mode);
  int creat(const char *pathname, mode_t mode);

  Description

  Given a pathname for a file, open() returns a file descriptor, a small,
  non-negative integer for use in subsequent system calls (read(2), write(2),
  lseek(2), fcntl(2), etc.). The file descriptor returned by a successful call
  will be the lowest-numbered file descriptor not currently open for the
  process.  The new file descriptor is set to remain open across an execve(2)
  (i.e., the FD_CLOEXEC file descriptor flag described in fcntl(2) is initially
  disabled). The file offset is set to the beginning of the file (see lseek(2)).
  """

  file_name_length = args[2]
  file_name = args[3][0:file_name_length]
  if "repy/lind" in file_name:
    return ErrorResponseBuilder("fs_open", "ENOENT", "not allowed to open system files" )

  # check old handles, if there, just return that one
  already_there = mycontext[FILES].lookupName(file_name)
  if already_there != 0:
    return SuccessResponseBuilder("fs_open", already_there )

  try:
    file_name = file_name.split("/")[-1]

    log("[info][syscall] Calling Open: " + file_name + "\n")
    f = openfile(file_name, False)
    file_handle = mycontext[FILES].insertFile(file_name, f)
        
  except FileNotFoundError,e:
    message = "Could not find file: " + file_name +"\n" +str(e) 
    log( message )
    return ErrorResponseBuilder("fs_open", "ENOENT", message )
  
  return SuccessResponseBuilder("fs_open", file_handle)


def lind_fs_read(args):
  try:
    log("[info][syscall] Lind FS Read was called.\n")
    handle = args[0]
    size = args[1]
    log("reading handle " + str(handle) + " of size " + str(size) + "\n")
    file_obj = mycontext[FILES].lookup(handle)
    fd = file_obj.fobj
    head = file_obj.location
    result = fd.readat(size, head)
    size_read = len(result)
    file_obj.location += size_read
    if size_read==0:
      #we are at EOF
      return SuccessResponseBuilder("fs_read", 0)
    

    log("[info][syscall] Lind FS Read Finished with: " + result + "\n")
  except:
    unimplemented("read failure")
  try:
    return SuccessResponseBuilder("fs_read", size_read, result)
  except:
    print "problem build return values"
    exitall()


def lind_fs_fstat(args):
  """
    struct stat {
               dev_t     st_dev;     /* ID of device containing file */
               ino_t     st_ino;     /* inode number */
               mode_t    st_mode;    /* protection */
               nlink_t   st_nlink;   /* number of hard links */
               uid_t     st_uid;     /* user ID of owner */
               gid_t     st_gid;     /* group ID of owner */
               dev_t     st_rdev;    /* device ID (if special file) */
               off_t     st_size;    /* total size, in bytes */
               blksize_t st_blksize; /* blocksize for file system I/O */
               blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
               time_t    st_atime;   /* time of last access */
               time_t    st_mtime;   /* time of last modification */
               time_t    st_ctime;   /* time of last status change */
           };

           This is 144 bytes long


  """
  
  fd = args[0]
  print "handle=",fd
  result = "\0"*144   # a 144 byte empty string
  unimplemented("fstat")
  return SuccessResponseBuilder("fs_fstat", 0, result)

def lind_fs_close(args):
  handle = args[0]
  try:
    file_obj = mycontext[FILES].lookup(handle)
    fd = file_obj.fobj
    fd.close()
  except:
    return  ErrorResponseBuilder("err_badf", "EBADF", "Bad file handle.")
  return SuccessResponseBuilder("fs_close", SUCCESS)


def lind_fs_lseek(args):
  print "LSeek was called with,", args
  unimplemented("lseek")
  return SuccessResponseBuilder("fs_lseek", SUCCESS)


def lind_fs_ioctl(args):
  print "IOCTL was called with,", args
  unimplemented("ioctl")
  return SuccessResponseBuilder("fs_ioctl", SUCCESS)


def lind_fs_access(args):
  print "ACCESS was called with,", args
  unimplemented("access")
  return SuccessResponseBuilder("fs_access", SUCCESS)


def lind_fs_unlink(args):
  print "UNLINK was called with,", args
  unimplemented("unlink")
  return ErrorResponseBuilder("fs_unlink", "ENOSYS", "unimplemented" )


def lind_fs_link(args):
  print "LINK was called with,", args
  unimplemented("link")
  return ErrorResponseBuilder("fs_link", "ENOSYS", "unimplemented" )


def lind_fs_chdir(args):
  print "CHDIR was called with,", args
  unimplemented("chdir")
  return ErrorResponseBuilder("fs_chdir", "ENOSYS", "unimplemented" )


def lind_fs_mkdir(args):
  print "MKDIR was called with,", args
  unimplemented("mkdir")
  return ErrorResponseBuilder("fs_mkdir", "ENOSYS", "unimplemented" )

def lind_fs_rmdir(args):
  print "RMDIR was called with,", args
  unimplemented("rmdir")
  return ErrorResponseBuilder("fs_rmdir", "ENOSYS", "unimplemented" )

  
def lind_err_enosys(args):
  return  ErrorResponseBuilder("err_enosys", "ENOSYS", "This system call is not implemented yet or disabled in Lind.")


def lind_sys_getpid(args):
  log("[info][syscall] Calling GetPID")
  # For now we dont want processes to know they are different than each other
  # maybe this could be a lind specific counter in the future?
  # what is the impact of doing this?
  DEFAULT_PID = 1000
  return SuccessResponseBuilder("sys_getpid", DEFAULT_PID)


def lind_debug_trace(args):
  print "[info][Trace] " + str(args[0])
  return SuccessResponseBuilder("debug_trace", 0)

def lind_fs_write(args):
  #TODO implement write
  print "Write was called!"
  size = args[1]
  return SuccessResponseBuilder("fs_write", size)


def dispatch_syscall(call, args):
  try:
    syscall_response = mycontext[SYSCALL][call](args)
  except KeyError,e:
    log("[ERROR][dispatch] Failed to look up " + str(call) + str(e) + "\n")
    syscall_response =  ErrorResponseBuilder("ENOSYS", "The system call is not in the system call table. Call="+str(call))
  
  assert isinstance(syscall_response, Response), "Returning something that is not a response. Check system calls: " + str(type(syscall_response)) + " form " + str(call)
  
  return syscall_response


def NaclRPCServer(nacl_instance):
  while True:
    format = "<i<I<I<i"
    try:
      message = nacl_instance.recv(1024)
    except exceptions.Exception:
      log("[ERROR][RPC] " + "Exception on receive\n")
      break
    # log("[info][RPC] " +  "Raw Message: "+ message +"\n")
    header = message[0:16]
    if header == "EOT":
      break
    magic = 0
    call = 0
    frmt_len = 0
    valid = 0
    try:
      [magic, call, frmt_len, valid] = struct_unpack(format, header)
    except Exception, err:
      log("[ERROR][RPC] " + str(type(err))+ ":"+str(err)+"\n")

    if magic != -2:
      raise Exception("Protocol Error: Magic number not found. Was expecting -2, got " + str(magic) )
    # We probably dont need this in the future, but for now:
    checksum = magic + call  + frmt_len

    if valid != checksum:
      raise Exception("Protocol Error: Validation number not found. We got " + str(valid) + ", expected " + str(checksum) )

    if frmt_len == 0:
      args = []
    else:
      args_string = message[16+frmt_len+1:]
      message_format = message[16:16+frmt_len]
      # print "message format: ", message_format
      try: 
        trimmed_string = args_string
        # print "Args: ",trimmed_string
        args = struct_unpack(message_format, trimmed_string)
        # print "Parsed Args", args
      except ValueError as e:
        log("Unpacking Error: " + str(e) + "\n")
        log("Message was: " + message_format + "\n")
        log("Args len=" + str(len(trimmed_string)) + "\n")
        log("Args full=" + str(args_string) + "\n")
        log("Args String=" + trimmed_string + "\n")
        call = 3 # continue on with eno_sys
        
    response = dispatch_syscall(call, args)
    if response == None:
      raise Exception()
    # print response
    retcode_buffer = response.make_struct()
    # print retcode_buffer
    try:
      got = nacl_instance.send(retcode_buffer,"")
    except:
      log("[info][RPC] " + "Exception on Send. Stopping\n")
      break
    if got == 0:
      log("[ERROR][RPC] " + "failed to send\n")

  print "Lind Server Shutting Down."

def main():
  code_loc = mycontext["program"]
  nacl = safelyexecutenativecode(code_loc, mycontext["commandline_args"])


  if nacl != None:
    NaclRPCServer(nacl)
  else:
    print "Safe Binary mode must be switched on for this program to work."



def setup_testing():
  """ Setup things for the test enviroment.  Remove from prouction version! """
  #check_file_io looks for foo.txt and reads it, so we must create it here.
  f = openfile("foo.txt", True)
  f2 = openfile("foo2.txt", True)
  f.writeat("Hello World", 0)
  f.close()
  f2.close()



def lind_factory():
  # map a systemcall number to a particular function
  mycontext[SYSCALL] = {1:lind_debug_trace,
                        2:lind_fs_access,
                        3:lind_err_enosys, 
                        4:lind_fs_unlink,
                        5:lind_fs_link,
                        6:lind_fs_chdir,
                        7:lind_fs_mkdir,
                        8:lind_fs_rmdir,                      
                        10:lind_fs_open,
                        11:lind_fs_close,
                        12:lind_fs_read,
                        13:lind_fs_write,
                        14:lind_fs_lseek,
                        15:lind_fs_ioctl,
                        17:lind_fs_fstat,
                        31:lind_sys_getpid}
                        
  
  #setup error codes
  mycontext["errno.h"] = {'ENOENT':2,  'ENOSYS':38 }

  #table of file handles
  mycontext["FILES"] = FileList()

  handle_offset = 10            # The amount by which we offset fileandles (so we
                                # dont clobber stdin out err and system file handles

  for i in range(0, handle_offset):
    mycontext["FILES"].insertFile("",None)

  setup_testing()

def parse_commandline():
  mycontext["program"] = callargs[0]
  mycontext["commandline_args"] = callargs[1:]

if callfunc == "initialize":
  parse_commandline()
  lind_factory()
  main()
