"""
The Lind OS Server.  This module services system calls coming from glibc
<Author>
  Chris Matthews (cmatthew@cs.uvic.ca)
<Start Date>
  Dececmber 2010
"""

include struct.repy

# if you comment this include out the line numbers are
# correct for syntax errors.
 

SYSCALL="syscall"               # shortcut to syscall dict items
FILES="FILES"                   # these also make a typo more specific
COMP="comp"                                # than a dict lookup error
ERRNO="errno.h"
MBOX="mbox"
LOCK="lock"
PROGRAM="program"
CMD_LINE="command_line_args"
SUCCESS=0

PRODUCTION=False
COMP_MODE="component_mode"

# def log(arg):
#   """Turn off logging"""
#   pass

def curr_comp():
  return mycontext[mycontext[COMP]]

def comp(num):
  return mycontext[num]

def unimplemented(who):
  """what to do when we come across some code that needs to be finished.
  For now, lets just keep running, but really this should not happen
  so we should exit.  """
  message =  "a unimplemented function has been called " + str(who)
  if PRODUCTION:
    log("error: " + message)
    exitall()
  else:
    log("warning: " + message)


class Response:
  """ An Response to a RPC request.

  <Purpose>

  This object is responsible sending responses to specific system calls.  It is
  loaded with data, then can build a reply struct which can then be sent back to
  NaCl through an IMC channel.

  The Response can be in one of two states, an Error response (for calls that
  have failed somehow), or a success response. An error response has an error
  code and a message for perror to display. A success has a return code and
  optionally a data string.

  TODO: error message is not yet displayed by perror.
  """
  message = "No error message set"
  data = ""

  def __init__(self, response_type,  is_error, return_code):
    assert isinstance(response_type, str), "response type is not a string"
    self.response_type = response_type
    assert isinstance(is_error, bool), "is error is not a boolean"
    self.is_error = is_error
    
    if isinstance(return_code, str):
      try:
        self.return_code =  curr_comp()[ERRNO][return_code]
      except KeyError:
        raise Exception("Return code is not a valid error number.")
    elif isinstance(return_code, int):
      self.return_code = return_code
    else:
      raise Exception("Invalid return code.")
    assert isinstance(self.return_code, int), "return code is not a int, or a stirng which mapped to an int"

  def make_struct(self):
    """
    <Purpose>

    Get the representation of this Response in struct format.  A struct is a
    string, which when sent to C can be cast as a struct and used nativly.
    The struct format is iiii123s, wich is:
    struct {
        int message_len;
        int magic_number;
        int is_in_error;
        int return_or_error_code;
        char data_or_message[];
    };

    """
    reply = None
    if self.is_error:
      # message format <is_error, code, message>
      reply = struct_pack("<i<i<i<i" + str(len(self.message)) + "s", len(self.message) + 12, 101010, 1, self.return_code, self.message)
    else:
      # message format <is_error, code, data>
      reply = struct_pack("<i<i<i<i" + str(len(self.data)) + "s", len(self.data) + 12, 101010, 0, self.return_code, self.data)
    return reply

  def __str__(self):
    """Human readable format for debugging"""
    if self.is_error:
      type_str = "Error"
    else:
      type_str = "Success"
    return type_str + " in " + self.response_type + " with code " + str(self.return_code) + " with data of size " + str(len(self.data)) + " with data " + str(self.data)

def ErrorResponseBuilder(who ,code, message):
  """ Build an error response object.

  <Arguments>
   who: Which portion of the system or system call is making this reply.
   code: Positive error code to return, or string from errno.h to resolve to a number.
   message: A detailed message about the error.
   """
  r = Response(who, True, code)
  r.message = message
  return r


def SuccessResponseBuilder(who, code, data=None):
  """Build an success response object.

  <Arugments>
     who: Which portion of the system or system call is making this reply.
     code: the integer return code to return.
     data: the data this call returns (as a string), if any.
  """
  r =  Response(who, False, code)
  if data!=None:
    r.data = data
  return r


def lind_fs_access(args):
  """
  NAME
       access - check real user's permissions for a file

  SYNOPSIS
       #include <unistd.h>

       int access(const char *pathname, int mode);

   DESCRIPTION
       access() checks whether the calling process can access the file pathname.
       If pathname is a symbolic link, it is dereferenced.

       The mode specifies the accessibility check(s) to be performed, and is
       either the value F_OK, or a mask consisting of the bitwise OR of one or
       file exists and grants read, write, and execute permissions,
       respectively.

       The check is done using the calling process's real UID and GID, rather
       than the effective IDs as is done when actually attempting an operation
       (e.g., open(2)) on the file.  This allows set-user-ID programs to easily
       determine the invoking user's author‚Äê ity.

       If the calling process is privileged (i.e., its real UID is zero), then
       an X_OK check is successful for a regular file if execute permission is
       enabled for any of the file owner, group, or other.

  RETURN VALUE
       On success (all requested permissions granted), zero is returned.  On
       error (at least one bit in mode asked for a permission that is denied, or
       some other error occurred), -1 is returned, and errno is set
       appropriately.

  ERRORS
       access() shall fail if:

       EACCES The requested access would be denied to the file, or search
       permission is denied for one of the directories in the path prefix of
       pathname.  (See also path_resolution(7).)

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling symbolic link.

       ENOTDIR A component used as a directory in pathname is not, in fact, a
              directory.

       EROFS Write permission was requested for a file on a read-only file
       system.

       access() may fail if:

       EFAULT pathname points outside your accessible address space.

       EINVAL mode was incorrectly specified.

       EIO    An I/O error occurred.

       ENOMEM Insufficient kernel memory was available.

       ETXTBSY Write access was requested to an executable which is being
              executed.
  """
  log("Calling Access")
  #TODO(cmatthew): implement basic checking
  unimplemented("access")
  return ErrorResponseBuilder("fs_access", "ENOSYS", "access system call is not implemented." )


class File:
  def __init__(self, name, fobj):
    self.name = name
    self.handle = -1
    self.fobj = fobj
    self.location = 0


class FileList:
  def __init__(self):
    self.list = []


  def insert(self, file_obj):
    assert isinstance(file_obj, File)
    self.list.append(file_obj)
    file_handle = self.list.index(file_obj)
    file_obj.handle = file_handle
    return file_handle


  def insertFile(self, file_name, fobj):
     f = File(file_name, fobj)
     return self.insert(f)


  def lookup(self, handle):
    return self.list[handle]


  def lookupName(self, name):
    for fobjs in self.list:
      if fobjs.name == name:
        return fobjs.handle
    return 0


def lind_fs_open(args):
  """int open(const char *pathname, int flags);
  int open(const char *pathname, int flags, mode_t mode);
  int creat(const char *pathname, mode_t mode);

  Description

  Given a pathname for a file, open() returns a file descriptor, a small,
  non-negative integer for use in subsequent system calls (read(2), write(2),
  lseek(2), fcntl(2), etc.). The file descriptor returned by a successful call
  will be the lowest-numbered file descriptor not currently open for the
  process.  The new file descriptor is set to remain open across an execve(2)
  (i.e., the FD_CLOEXEC file descriptor flag described in fcntl(2) is initially
  disabled). The file offset is set to the beginning of the file (see lseek(2)).
  """

  file_name_length = args[2]
  file_name = args[3]
  if "repy/lind" in file_name:
    return ErrorResponseBuilder("fs_open", "ENOENT", "not allowed to open system files" )

  # check old handles, if there, just return that one
  already_there = curr_comp()[FILES].lookupName(file_name)
  if already_there != 0:
    return SuccessResponseBuilder("fs_open", already_there )
  if file_name == "lind://component-manager":
    COMP_MANAGER_FD = 9
    return SuccessResponseBuilder("fs_open", COMP_MANAGER_FD )
    
  try:
    file_name = file_name.split("/")[-1]
    if file_name in curr_comp()[PROGRAM]:
      return ErrorResponseBuilder("fs_open", "ENOENT", "won't allow open of program file" )

    log("[info][syscall] Calling Open: " + file_name + "\n")
    f = openfile(file_name, False)
    file_handle = curr_comp()[FILES].insertFile(file_name, f)
        
  except FileNotFoundError,e:
    message = "Could not find file: " + file_name +"\n" + str(e) + "\n" 
    log( message )
    return ErrorResponseBuilder("fs_open", "ENOENT", message )
  
  return SuccessResponseBuilder("fs_open", file_handle)


def lind_fs_read(args):
  try:
    log("[info][syscall] Lind FS Read was called.\n")
    handle = args[0]
    size = args[1]
    log("reading handle " + str(handle) + " of size " + str(size) + "\n")
    file_obj = curr_comp()[FILES].lookup(handle)
    fd = file_obj.fobj
    head = file_obj.location
    result = fd.readat(size, head)
    size_read = len(result)
    file_obj.location += size_read
    if size_read==0:
      #we are at EOF
      return SuccessResponseBuilder("fs_read", 0)
    

    log("[info][syscall] Lind FS Read Finished with: " + result + "\n")
  except:
    unimplemented("read failure")
  try:
    return SuccessResponseBuilder("fs_read", size_read, result)
  except:
    print "problem build return values"
    exitall()





# JAC: I think this should call the lind_fs_stat call and do the below
# work there...
def lind_fs_fstat(args):
  """
    struct stat {
 8             dev_t      st_dev;     /* ID of device containing file */
 8             ino64_t    st_ino;     /* inode number */
 4             mode_t     st_mode;    /* protection */
 4             nlink_t    st_nlink;   /* number of hard links */
 4             uid_t      st_uid;     /* user ID of owner */
 4             gid_t      st_gid;     /* group ID of owner */
 8             dev_t      st_rdev;    /* device ID (if special file) */
 8             off64_t    st_size;    /* total size, in bytes */
 8             blksize_t  st_blksize; /* blocksize for file system I/O */
 8             blkcnt64_t st_blocks;  /* number of 512B blocks allocated */
 16            struct timespec   st_atime;   /* time of last access */
 16            struct timespec   st_mtime;   /* time of last modification */
 16            struct timespec   st_ctime;   /* time of last status change */
           };

    struct timespec
    {
 8             time_t   tv_sec;
 8             long int   tv_nsec;
    };

           This is 112 bytes long

  """

  assert(len(args)==1)
  assert(type(args[0]) is int or type(args[0]) is long)
  assert(0 <= args[0] <=1024)


  filedes = args[0]
  

  # My general philisophy is to make the arguments return reasonable modes
  # whenever possible.   For directories, I'll return the mode string: 
  # 16877 -> 0100000111101101 which corresponds to drwxr-xr-x.  The 16384 bit
  # is 'directory'.  For files, I'll do 33261 -> 01000000111101101 which is 
  # -rwxr-x-r-x.   The 32768 bit is 'regular file'.  I'm skipping other items
  # for now.
  # (some information from: http://docs.python.org/library/stat.html)

  # A directory should not be opened, so let's choose the file perms...
  my_st_mode = 33261
  # BUG: This may not work with other file perm actions

  # uid / gid can correspond to the default user
  my_st_uid = my_st_gid = 1000

  # number of links, let's set to 1 for now...
  my_st_nlink = 1

  # the device containing the item...   Let's use 2049 since this is what is
  # seen on the lind VM
  my_st_dev = 2049
  
  # for now, let me assume that we can just use the same inode for everything.
  # I chose a random file's inode.
  my_st_ino = 840940
  
  #  Python's stat command on linux does not have the following fields:
  #     st_rdev, st_blksize, st_blocks.   I will ignore those.
  my_st_rdev = my_st_blksize = my_st_blocks = 0
  
  # I will set the access, modification and creation times to all be the same
  # value for now.   I chose a time when I was writing this: 1323630836
  my_st_atime = my_st_ctime = my_st_mtime = 1323630836

  # TODO: This will not work for make, etc.
  
  # need to compute the size...
  fileobj = curr_comp()[FILES].lookup(filedes)
  # BUG: This is very inefficient for large files!!!
  my_st_size = len(fileobj.fobj.readat(None,0))
  

  # This format is: dev,ino,mode,nlink,uid,gid,rdev,size,blksize,blocks
  # followed by 2Q for each timestamp.   The ns field is set to 0.
  result = struct_pack('<Q<Q<I<I<I<I<Q<q<q<q<Q<Q<Q<Q<Q<Q',
      my_st_dev,my_st_ino,my_st_mode,my_st_nlink,my_st_uid,my_st_gid,
      my_st_rdev,my_st_size,my_st_blksize,my_st_blocks,
      my_st_atime,0,my_st_mtime,0,my_st_ctime,0)

  return SuccessResponseBuilder("fs_fstat", 0, result)




def lind_fs_close(args):
  handle = args[0]
  try:
    file_obj = curr_comp()[FILES].lookup(handle)
    fd = file_obj.fobj
    fd.close()
  except:
    return  ErrorResponseBuilder("err_badf", "EBADF", "Bad file handle.")
  return SuccessResponseBuilder("fs_close", SUCCESS)


def lind_fs_lseek(args):
  log("LSeek was called with," + str(args))
  unimplemented("lseek")
  return SuccessResponseBuilder("fs_lseek", SUCCESS)


def lind_fs_ioctl(args):
  log("IOCTL was called with,"+ str(args))
  unimplemented("ioctl")
  return SuccessResponseBuilder("fs_ioctl", SUCCESS)


def lind_fs_access(args):
  log("ACCESS was called with," + str(args))
  unimplemented("access")
  return SuccessResponseBuilder("fs_access", SUCCESS)


def lind_fs_unlink(args):
  log("UNLINK was called with," + str(args))
  unimplemented("unlink")
  return ErrorResponseBuilder("fs_unlink", "ENOSYS", "unimplemented" )


def lind_fs_link(args):
  log("LINK was called with,"+ str(args))
  unimplemented("link")
  return ErrorResponseBuilder("fs_link", "ENOSYS", "unimplemented" )


def lind_fs_chdir(args):
  log("CHDIR was called with,"+ str(args))
  unimplemented("chdir")
  return ErrorResponseBuilder("fs_chdir", "ENOSYS", "unimplemented" )


def lind_fs_mkdir(args):
  log("MKDIR was called with," + str(args))
  unimplemented("mkdir")
  return ErrorResponseBuilder("fs_mkdir", "ENOSYS", "unimplemented" )


def lind_fs_rmdir(args):
  log("RMDIR was called with," + str(args))
  unimplemented("rmdir")
  return ErrorResponseBuilder("fs_rmdir", "ENOSYS", "unimplemented" )


def lind_fs_xstat(args):
  log("XSTAT was called with," + str(args))
  unimplemented("xstat")
  return ErrorResponseBuilder("fs_xstat", "ENOSYS", "unimplemented" )

  
def lind_err_enosys(args):
  return  ErrorResponseBuilder("err_enosys", "ENOSYS", "This system call is not implemented yet or disabled in Lind.")


def lind_sys_getpid(args):
  log("[info][syscall]",mycontext[COMP] ," Calling GetPID\n")
  # For now we dont want processes to know they are different than each other
  # maybe this could be a lind specific counter in the future?
  # what is the impact of doing this?
  DEFAULT_PID = 1000
  return SuccessResponseBuilder("sys_getpid", DEFAULT_PID)


def lind_debug_trace(args):
  log("[info][Trace]["+ str(mycontext[COMP])+"] ", args[0],"\n")
  return SuccessResponseBuilder("debug_trace", 0)


def lind_debug_noop(args):
  return SuccessResponseBuilder("debug_noop", 0)


def lind_fs_write(args):
  #TODO implement write
  log("[info][syscall]Write was called!")
  size = args[1]
  return SuccessResponseBuilder("fs_write", size)


def lind_comp_cia(args):
  """Component Interface Attach"""
  log("[info][syscall]Component Interface Attach Called with", args, "\n")

  # for now, just return the other compoent
  target = 0
  if mycontext[COMP] == 1:
    target = 2
  else:
    target = 1

  return SuccessResponseBuilder("comp_cia", target)


def lind_comp_call(args):
  """Component Call"""
  log("[info][syscall]Component Call Called with" + str(args),"\n")
  message = args[3]
  target_comp = args[0]
  comp(target_comp)[MBOX].append(message)
  return SuccessResponseBuilder("comp_call", 0)


def lind_comp_accept(args):
  """Component Accept"""
  log("[info][syscall]Component Accept Called with", args, "\n")
  try:
    mesg = curr_comp()[MBOX].pop(0)
  except IndexError:
    return SuccessResponseBuilder("comp_accpet", 0)
  return SuccessResponseBuilder("comp_accpet", len(mesg), mesg)


def lind_comp_recv(args):
  """Component Recv"""
  log("[info][syscall]Component Recv called with ", args, "\n")
  
  return SuccessResponseBuilder("comp_recv", 0)


def dispatch_syscall(call, args):
  try:
    syscall_response = curr_comp()[SYSCALL][call](args)
    

  except KeyError,e:
    log("[ERROR][dispatch] Failed to look up " + str(call) + str(e) + "\n")
    syscall_response =  ErrorResponseBuilder("ENOSYS", "The system call is not in the system call table. Call="+str(call))
  
  assert isinstance(syscall_response, Response), "Returning something that is not a response. Check system calls: " + str(type(syscall_response)) + " form " + str(call)
  
  return syscall_response


def print_times(times):
  print "\nSummary of System Call Execution Times:"
  prefix = ">> "  # prefix which the shell scripts can use to pull out these numbers
  for eachtime in times:
    each = 0
    call = eachtime[each]
    each += 1
    # using the call number, pull the string name out of the function object
    function_name = str(curr_comp()[SYSCALL][call]).split(" ")[1]
    exec_pre = eachtime[each]
    each += 1
    exec_start = eachtime[each]
    each += 1
    exec_post = eachtime[each] 
    each += 1
    exec_stop = eachtime[each] 
    each += 1
    exec_before = eachtime[each] 
    each += 1
    exec_after = eachtime[each] 
    each += 1
    call_args = eachtime[each]
    print prefix, function_name + ", "+ "%f"%(exec_pre) + ", " + "%f"%(exec_start) + ", " + "%f"%(exec_post) + ", " + "%f"%(exec_stop) + ", " + "%f"%(exec_before) + ", " + "%f"%(exec_after) + ", \"" + str(call_args) + "\""

NOOP_CALL_NUM=1



def NaclRPCServer(nacl_instance, comp_num):
  #timer =  mycontext["wallclocktime"]
  #times = []
  while True:
    format = "<i<I<I<i"
    start = 0
    stop = 0
    try:
     # pre = timer()
      message = nacl_instance.recv(1024)
     # start = timer()
    except exceptions.Exception:
      log("[ERROR][RPC] " + "Exception on receive\n")
      break
  
    # log("[info][RPC] " +  "Raw Message: "+ message +"\n")
    header = message[0:16]
    if header == "EOT":
      break
    magic = 0
    call = 0
    frmt_len = 0
    valid = 0
    try:
      [magic, call, frmt_len, valid] = struct_unpack(format, header)
    except Exception, err:
      log("[ERROR][RPC] ", type(err),  ":", err, "\n")

    if magic != -2:
      raise Exception("Protocol Error: Magic number not found. Was expecting -2, got " + str(magic) )
    # We probably dont need this in the future, but for now:
    checksum = magic + call  + frmt_len

    if valid != checksum:
      raise Exception("Protocol Error: Validation number not found. We got " + str(valid) + ", expected " + str(checksum) )

    if frmt_len == 0:
      args = []
    else:
      args_string = message[16+frmt_len+1:]
      message_format = message[16:16+frmt_len]
      # print "message format: ", message_format
      try: 
        trimmed_string = args_string
        # print "Args: ",trimmed_string
        args = struct_unpack(message_format, trimmed_string)
        # print "Parsed Args", args
      except ValueError as e:
        log("Unpacking Error: " + str(e) + "\n")
        log("Message was: " + message_format + "\n")
        log("Args len=" + str(len(trimmed_string)) + "\n")
        log("Args full=" + str(args_string) + "\n")
        log("Args String=" + trimmed_string + "\n")
        call = NOOP_CALL_NUM # continue on with eno_sys
    # before_call = timer()
    mycontext[LOCK].acquire(True)
    mycontext[COMP] = comp_num
    response = dispatch_syscall(call, args)
    mycontext[LOCK].release()
    # after_call = timer()
    if response == None:
      raise Exception()
    # print response
    retcode_buffer = response.make_struct()
    # print retcode_buffer
    try:
      # post = timer()
      got = nacl_instance.send(retcode_buffer,"")
      # stop = timer()
    except:
      log("[info][RPC] " + "Exception on Send. Stopping\n")
      break
    if got == 0:
      log("[ERROR][RPC] " + "failed to send\n")
    # times.append((call, pre ,start, post, stop, before_call, after_call, args))
    
  print "Lind Server ", mycontext[comp_num][PROGRAM], " Shutting Down."
  # print_times(times)


def main():
  code_loc = curr_comp()[PROGRAM]
  nacl = safelyexecutenativecode(code_loc, curr_comp()[CMD_LINE])

  if nacl != None:
    NaclRPCServer(nacl, 1)
  else:
    print "Safe Binary mode must be switched on for this program to work."
    

def setup_testing():
  """ Setup things for the test enviroment.  Remove from prouction version! """
  #check_file_io looks for foo.txt and reads it, so we must create it here.
  print "Warning: adding files for testing."
  f = openfile("foo.txt", True)
  f2 = openfile("foo2.txt", True)
  f.writeat("Hello World", 0)
  f.close()
  f2.close()

def launch_helper(instance, num):
  """save the instance and start the server in a thread."""
  def closure():
    NaclRPCServer(instance, num)
  createthread(closure)
  
def new_compoent():
  """add a new compoent to the system"""
  mycontext[2]={}
  code_loc = "liblind/com2.nexe"
  mycontext[2][PROGRAM] = code_loc
  mycontext[2][CMD_LINE] = []
  setup_dispatcher(2)
  setup_filetable(2)
  setup_component_communication(2)
  nacl = safelyexecutenativecode(code_loc, [])
  
  
  if nacl != None:
    launch_helper(nacl, 2)
  else:
    print "Safe Binary mode must be switched on for this program to work."


def setup_dispatcher(comp_num):
  # map a systemcall number to a particular function
  comp(comp_num)[SYSCALL] = {
    1:lind_debug_noop,
    2:lind_fs_access,
    3:lind_debug_trace,
    4:lind_fs_unlink,
    5:lind_fs_link,
    6:lind_fs_chdir,
    7:lind_fs_mkdir,
    8:lind_fs_rmdir,                      
    9:lind_fs_xstat,                      
    10:lind_fs_open,
    11:lind_fs_close,
    12:lind_fs_read,
    13:lind_fs_write,
    14:lind_fs_lseek,
    15:lind_fs_ioctl,
    17:lind_fs_fstat,
    31:lind_sys_getpid,
    105:lind_comp_cia,
    106:lind_comp_call,
    107:lind_comp_accept,
    108:lind_comp_recv
    }
  
  #setup error codes
  comp(comp_num)[ERRNO] = {'ENOENT':2,  'ENOSYS':38 }


def setup_filetable(comp_num):
  #table of file handles
  comp(comp_num)[FILES] = FileList()

  handle_offset = 10            # The amount by which we offset fileandles (so we
                                # dont clobber stdin out err and system file handles

  for i in range(0, handle_offset):
    comp(comp_num)[FILES].insertFile("",None)


def setup_component_communication(comp_num):
    comp(comp_num)[MBOX] = []

 
def lind_factory():

  setup_dispatcher(1)
  setup_filetable(1)
  setup_component_communication(1)
  mycontext[LOCK] = createlock()
  # are we running the C test program? if so make testing files
  if "glibc_test" in curr_comp()[PROGRAM]:
    setup_testing()

  #if we are running a compoent, launch another one as a test.  
  if "com1" in curr_comp()[PROGRAM]:
    log("starting multi-component test mode")
    mycontext[COMP_MODE] = True
    new_compoent()
  else:
    mycontext[COMP_MODE] = False


def parse_commandline():
  mycontext[COMP] = 1
  mycontext[1] = {}
  curr_comp()[PROGRAM] = callargs[0]
  print curr_comp()[PROGRAM]
  curr_comp()[CMD_LINE] = callargs[1:]

if callfunc == "initialize":
  parse_commandline()
  lind_factory()
  main()
  log("Exiting Lind")
