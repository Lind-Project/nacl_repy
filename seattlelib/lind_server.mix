"""
The Lind OS Server.  This module services system calls coming from glibc
<Author>
  Chris Matthews (cmatthew@cs.uvic.ca)
<Start Date>
  Dececmber 2010
"""

include struct.repy

VERSION = "$Rev$"

TRACE = False  # Trace system calls? (somewhat like strace) 

SYSCALL = "syscall"               # shortcut to syscall dict items
FILES = "FILES"                   # these also make a typo more specific
COMP = "comp"                                # than a dict lookup error
ERRNO = "errno.h"
MBOX = "mbox"
LOCK = "lock"
PROGRAM = "program"
CMD_LINE = "command_line_args"
SUCCESS = 0

PRODUCTION = False
COMP_MODE = "component_mode"

# the size of the transmission buffer.  We should never send something
# bigger than this!
TX_BUF_MAX = (4096 * 4) - 16   # 16 bytes of header
RX_BUF_MAX = (4096 * 4)


# if not TRACE:
#   def log(arg):
#     """Turn off logging"""
#     pass


def warning(logic, message):
  """Like assert, but only warn"""
  if not logic:
    log( "Warning:"+ message)


def curr_comp():
  return mycontext[mycontext[COMP]]


def comp(num):
  return mycontext[num]


def unimplemented(who):
  """what to do when we come across some code that needs to be finished.
  For now, lets just keep running, but really this should not happen
  so we should exit.  """
  message = "a unimplemented function has been called " + str(who)
  if PRODUCTION:
    log("error: " + message)
    exitall()
  else:
    log("warning: " + message)


class Response:
  """ An Response to a RPC request.

  <Purpose>

  This object is responsible sending responses to specific system calls.  It is
  loaded with data, then can build a reply struct which can then be sent back
  to NaCl through an IMC channel.

  The Response can be in one of two states, an Error response (for calls that
  have failed somehow), or a success response. An error response has an error
  code and a message for perror to display. A success has a return code and
  optionally a data string.

  TODO: error message is not yet displayed by perror.
  """
  message = "No error message set"
  data = ""

  def __init__(self, response_type, is_error, return_code):
    assert isinstance(response_type, str), "response type is not a string"
    self.response_type = response_type
    assert isinstance(is_error, bool), "is error is not a boolean"
    self.is_error = is_error

    if isinstance(return_code, str):
      try:
        self.return_code = curr_comp()[ERRNO][return_code]
      except KeyError:
        raise Exception("Return code is not a valid error number.")
    elif isinstance(return_code, int):
      self.return_code = return_code
    else:
      raise Exception("Invalid return code.")
    assert isinstance(self.return_code, int), \
           "return code is not a int, or a stirng which mapped to an int"

  def make_struct(self):
    """
    <Purpose>

    Get the representation of this Response in struct format.  A struct is a
    string, which when sent to C can be cast as a struct and used nativly.
    The struct format is iiii123s, wich is:
    struct {
        int message_len;
        int magic_number;
        int is_in_error;
        int return_or_error_code;
        char data_or_message[];
    };

    """
    reply = None
    if self.is_error:
      # message format <size, magic, is_error, code, message>
      reply = struct_pack("<i<i<i<i" + str(len(self.message)) + "s", \
                          len(self.message) + 16, \
                          101010, 1, self.return_code,\
                          self.message)
    else:
      # message format <size, magic, is_error, code, data>
      reply = struct_pack("<i<i<i<i" + str(len(self.data)) + "s", \
                          len(self.data) + 16, 101010, 0, self.return_code,\
                          self.data)
    return reply

  def __str__(self):
    """Human readable format for debugging"""
    if self.is_error:
      type_str = "Error"
    else:
      type_str = "Success"
    return type_str + " in " + self.response_type + " with code " + \
           str(self.return_code) + " with data of size " + str(len(self.data))\
           + " with data " + str(self.data)


def ErrorResponseBuilder(who, code, message):
  """ Build an error response object.

  <Arguments>
   who: Which portion of the system or system call is making this reply.
   code: Positive error code to return, or string from errno.h to resolve
   to a number.

   message: A detailed message about the error.
   """
  r = Response(who, True, code)
  r.message = message
  return r


def SuccessResponseBuilder(who, code, data=None):
  """Build an success response object.

  <Arugments>
     who: Which portion of the system or system call is making this reply.
     code: the integer return code to return.
     data: the data this call returns (as a string), if any.
  """
  r = Response(who, False, code)
  if data != None:
    r.data = data
  return r


def check_valid_fd_handle(num):
  assert isinstance(num, int)
  assert (10 <= num <= MAX_FD), "invalid handle %d" % num


include lind_parsers.repy

include lind_fs_constants.py

include lind_net_constants.py

include serialize.repy

include lind_fs_calls.py

include lind_net_calls.py

include fs_open.repy

include fs_write.repy

include fs_fstatfs.repy

include fs_statfs.repy

include comp.repy

include fs_access.repy

include fs_read.repy

include fs_fstat.repy

include fs_close.repy

include fs_lseek.repy

include fs_mkdir.repy

include fs_rmdir.repy

include fs_chdir.repy

include fs_link.repy

include fs_unlink.repy

include fs_xstat.repy

include fs_getdents.repy

include fs_dup.repy

include fs_dup2.repy

include fs_fcntl.repy

include sys_getpid.repy

include net_socket.repy

include net_bind.repy

include net_send.repy

include net_sendto.repy

include net_recv.repy

include net_recvfrom.repy

include net_connect.repy

include net_listen.repy

include net_accept.repy

include net_getpeername.repy

include net_getsockname.repy

include net_getsockopt.repy

include net_setsockopt.repy

include net_shutdown.repy

include net_select.repy

include net_getifaddrs.repy

include debug.repy

include unimplemented_syscalls.repy

include dispatcher.repy


def print_times(times):
  print "\nSummary of System Call Execution Times:"
  prefix = ">> "  # prefix which the scripts can use to pull out these numbers
  for eachtime in times:
    each = 0
    call = eachtime[each]
    each += 1
    # using the call number, pull the string name out of the function object
    function_name = str(curr_comp()[SYSCALL][call]).split(" ")[1]
    exec_pre = eachtime[each]
    each += 1
    exec_start = eachtime[each]
    each += 1
    exec_post = eachtime[each]
    each += 1
    exec_stop = eachtime[each]
    each += 1
    exec_before = eachtime[each]
    each += 1
    exec_after = eachtime[each]
    each += 1
    call_args = eachtime[each]
    print prefix, function_name + ", " + "%f" % (exec_pre) + ", " + \
          "%f" % (exec_start) + ", " + "%f" % (exec_post) + ", " + \
          "%f" % (exec_stop) + ", " + "%f" % (exec_before) + ", " + \
          "%f" % (exec_after) + ", \"" + str(call_args) + "\""


def NaclRPCServer(nacl_instance, comp_num):
  #timer =  mycontext["wallclocktime"]
  #times = []
  format = "<i<I<I<I<i<i"
  header_size = struct_calcsize(format)
  max_recv = 16384
  # the expceted message sequence number
  FIRST_SEQ_NUM = -10
  expected_seq_num = FIRST_SEQ_NUM
  booting = True
  while True:
    start = 0
    stop = 0
    response = "Failed with Exception."

    # step 1: pull out the header
    try:
     # pre = timer()
      message = nacl_instance.recv(max_recv)
     # start = timer()
    except exceptions.Exception:
      log("[ERROR][RPC] " + "Exception on receive\n")
      break

    # log("[info][RPC] " +  "Raw Message: "+ message +"\n")
    # assert( len(message) == header_size), "wrong header size"
    if message == "EOT":
      break

    header = message[0:header_size]

    # now parse the header
    magic = 0
    call = 0
    frmt_len = 0
    valid = 0
    payload_size = 0
    seq_num = 0

    try:
      [magic, call, frmt_len, payload_size, seq_num, valid] = struct_unpack(format, header)
    except Exception, err:
      log("[ERROR][RPC] Error unmarshaling header" + type(err) + ":" + err + "\n")

    # validate the header
    if magic != -2:
      raise Exception("Protocol Error: Magic number not found." + \
                      " Was expecting -2, got " + str(magic))
    # We probably dont need this in the future, but for now:
    checksum = magic + call + frmt_len

    # what happens is that libc overwrites the counter pretty early on
    # for that first, but once that has happened, keep a constat counter.
    if booting:
      if (seq_num != expected_seq_num):
        expected_seq_num = FIRST_SEQ_NUM
        booting = False
        print "Booted"
    elif (seq_num != expected_seq_num):
      pass
#      print "Out of order seq_num %d != %d for call %d" % \
#           (seq_num, expected_seq_num, call)

    expected_seq_num += 1
    if valid != checksum:
      raise Exception("ProtocolError: Validation number not found. We got " + \
                      str(valid) + ", expected " + str(checksum))


    if frmt_len == 0:
      args = []
    else:
      data_start = header_size + frmt_len + 1  # one extra for null char at end of frmt string
      # the part of the string which is the format string
      message_format = message[header_size:data_start-1]
      # print "message format: ", message_format
      try:
        trimmed_string = message[data_start:]
        assert len(trimmed_string) == payload_size, "Reported (%d) payload does not match actual payload (%d)" % (len(trimmed_string), payload_size)
        # print "Args: ",trimmed_string
        args = struct_unpack(message_format, trimmed_string)
        # print "Parsed Args", args
      except ValueError as e:
        log("Unpacking Error: " + str(e) + "\n")
        log("Message was: " + message_format + "\n")
        log("Args len=" + str(len(trimmed_string)) + "\n")
        log("Args String=" + trimmed_string + "\n")
        log("Syscall was=" + str(call) + "\n")
        call = NOOP_CALL_NUM # continue on with eno_sys
    if TRACE:
      strace_msg = [ "[lind_server][trace]", str(str(curr_comp()[SYSCALL][call]).split(" ")[1]), str(args), " = "]

    # before_call = timer()
    mycontext[LOCK].acquire(True)
    mycontext[COMP] = comp_num
    try:
      response = dispatch_syscall(call, args)
    finally:
      if TRACE:
        strace_msg.append(str(response))
        print ''.join(strace_msg)
    mycontext[LOCK].release()
    if response == None:
      raise Exception()

    retcode_buffer = response.make_struct()

    try:
      # post = timer()
      got = nacl_instance.send(retcode_buffer, "")
      # stop = timer()
    except:
      log("[info][RPC] " + "Exception on Send. Stopping\n")
      break
    if got == 0:
      log("[ERROR][RPC] " + "failed to send\n")
      exitall()
  #print "Lind Server ", mycontext[comp_num][PROGRAM], " Shutting Down."
  # print_times(times)


def main():
  code_loc = curr_comp()[PROGRAM]
  nacl = safelyexecutenativecode(code_loc, curr_comp()[CMD_LINE])

  if nacl != None:
    NaclRPCServer(nacl, 1)
  else:
    print "Error: Safe Binary mode must be switched on for this program to work."


def launch_helper(instance, num):
  """save the instance and start the server in a thread."""

  def closure():
    NaclRPCServer(instance, num)
  createthread(closure)

def _check_file(name):
  if name.startswith("./"):
    cleanname = name[2:]
  else:
    cleanname = name
  try:
    f = openfile(cleanname, False)
    f.readat(0,100)
    f.close()
  except FileNotFoundError:
    print "File not found:", name
    exitall()
    


def new_compoent():
  """add a new compoent to the system"""
  mycontext[2] = {}
  code_loc = "liblind/com2.nexe"
  mycontext[2][PROGRAM] = code_loc
  
  mycontext[2][CMD_LINE] = []
  setup_dispatcher(2)
  setup_filetable(2)
  setup_component_communication(2)
  nacl = safelyexecutenativecode(code_loc, [])


  if nacl != None:
    launch_helper(nacl, 2)
  else:
    print "Safe Binary mode must be switched on for this program to work."


def setup_filetable(comp_num):
  """Try to open file system. If you can't, then make a new one."""
  print "Opening file system... ",
  load_fs()

  print "done."

  # except KeyError, e:


def setup_component_communication(comp_num):
    comp(comp_num)[MBOX] = []


def lind_factory():

  setup_dispatcher(1)
  setup_filetable(1)
  setup_component_communication(1)
  mycontext[LOCK] = createlock()
  _check_file(curr_comp()[PROGRAM])
  #if we are running a compoent, launch another one as a test.
  if "com1" in curr_comp()[PROGRAM]:
    log("starting multi-component test mode")
    mycontext[COMP_MODE] = True
    new_compoent()
  else:
    mycontext[COMP_MODE] = False


def parse_commandline():
  mycontext[COMP] = 1
  mycontext[1] = {}
  
  if callargs[0] == "--fast":
    curr_comp()[PROGRAM] = callargs[1]
    curr_comp()[CMD_LINE] = callargs[2:]
    curr_comp()[CMD_LINE].append("--fast")
  else:
    curr_comp()[PROGRAM] = callargs[0]
    curr_comp()[CMD_LINE] = callargs[1:]
  # print curr_comp()[PROGRAM]



if callfunc == "initialize":
  print "Lind v0." + VERSION[6:-2], "Last commit:", "$Date$"[7:-2]
  parse_commandline()
  lind_factory()

  main()

  log("Persisting metadata: ... ")
  persist_metadata(DEFAULT_METADATA_FILENAME)
  log("Done persisting metadata.")

  
