"""
The Lind OS Server.  This module services system calls coming from glibc
<Author>
  Chris Matthews (cmatthew@cs.uvic.ca)
<Start Date>
  Dececmber 2010
"""

include struct.repy

# if you comment this include out the line numbers are
# correct for syntax errors.
 

SYSCALL="syscall"               # shortcut to syscall dict items
FILES="FILES"                   # these also make a typo more specific
COMP="comp"                                # than a dict lookup error
ERRNO="errno.h"
MBOX="mbox"
LOCK="lock"
PROGRAM="program"
CMD_LINE="command_line_args"
SUCCESS=0

PRODUCTION=False
COMP_MODE="component_mode"




# def log(arg):
#   """Turn off logging"""
#   pass

def curr_comp():
  return mycontext[mycontext[COMP]]


def comp(num):
  return mycontext[num]

def unimplemented(who):
  """what to do when we come across some code that needs to be finished.
  For now, lets just keep running, but really this should not happen
  so we should exit.  """
  message =  "a unimplemented function has been called " + str(who)
  if PRODUCTION:
    log("error: " + message)
    exitall()
  else:
    log("warning: " + message)


class Response:
  """ An Response to a RPC request.

  <Purpose>

  This object is responsible sending responses to specific system calls.  It is
  loaded with data, then can build a reply struct which can then be sent back to
  NaCl through an IMC channel.

  The Response can be in one of two states, an Error response (for calls that
  have failed somehow), or a success response. An error response has an error
  code and a message for perror to display. A success has a return code and
  optionally a data string.

  TODO: error message is not yet displayed by perror.
  """
  message = "No error message set"
  data = ""

  def __init__(self, response_type,  is_error, return_code):
    assert isinstance(response_type, str), "response type is not a string"
    self.response_type = response_type
    assert isinstance(is_error, bool), "is error is not a boolean"
    self.is_error = is_error
    
    if isinstance(return_code, str):
      try:
        self.return_code =  curr_comp()[ERRNO][return_code]
      except KeyError:
        raise Exception("Return code is not a valid error number.")
    elif isinstance(return_code, int):
      self.return_code = return_code
    else:
      raise Exception("Invalid return code.")
    assert isinstance(self.return_code, int), "return code is not a int, or a stirng which mapped to an int"

  def make_struct(self):
    """
    <Purpose>

    Get the representation of this Response in struct format.  A struct is a
    string, which when sent to C can be cast as a struct and used nativly.
    The struct format is iiii123s, wich is:
    struct {
        int message_len;
        int magic_number;
        int is_in_error;
        int return_or_error_code;
        char data_or_message[];
    };

    """
    reply = None
    if self.is_error:
      # message format <size, magic, is_error, code, message>
      reply = struct_pack("<i<i<i<i" + str(len(self.message)) + "s", len(self.message) + 16, 101010, 1, self.return_code, self.message)
    else:
      # message format <size, magic, is_error, code, data>
      reply = struct_pack("<i<i<i<i" + str(len(self.data)) + "s", len(self.data) + 16, 101010, 0, self.return_code, self.data)
    return reply

  def __str__(self):
    """Human readable format for debugging"""
    if self.is_error:
      type_str = "Error"
    else:
      type_str = "Success"
    return type_str + " in " + self.response_type + " with code " + str(self.return_code) + " with data of size " + str(len(self.data)) + " with data " + str(self.data)

def ErrorResponseBuilder(who ,code, message):
  """ Build an error response object.

  <Arguments>
   who: Which portion of the system or system call is making this reply.
   code: Positive error code to return, or string from errno.h to resolve to a number.
   message: A detailed message about the error.
   """
  r = Response(who, True, code)
  r.message = message
  return r


def SuccessResponseBuilder(who, code, data=None):
  """Build an success response object.

  <Arugments>
     who: Which portion of the system or system call is making this reply.
     code: the integer return code to return.
     data: the data this call returns (as a string), if any.
  """
  r =  Response(who, False, code)
  if data!=None:
    r.data = data
  return r


def check_valid_fd_handle(num):
  assert isinstance(num, int)
  assert (10 <= num <= MAX_FD), "invalid handle"



def pack_stat_struct(struct_tuple):
  """Given a tuple with stat fields, pack it into a string"""
  (my_st_dev, my_st_ino, my_st_mode, my_st_nlink, my_st_uid, my_st_gid,
   my_st_rdev, my_st_size, my_st_blksize, my_st_blocks,
   my_st_atime, my_st_atimeus, my_st_mtime, my_st_mtimeus, my_st_ctime,my_st_ctimeus) = struct_tuple
  result = struct_pack('<Q<Q<I<I<I<I<Q<q<q<q<Q<Q<Q<Q<Q<Q',
                       my_st_dev,my_st_ino,my_st_mode,my_st_nlink,my_st_uid,my_st_gid,
                       my_st_rdev,my_st_size,my_st_blksize,my_st_blocks,
                       my_st_atime,my_st_atimeus, my_st_mtime,my_st_mtimeus,my_st_ctime,my_st_ctimeus)
  return result

def pack_statfs_struct(fsd):
  """struct statfs {
  long    f_type;     -- type of file system (see below) 
  long    f_bsize;    -- optimal transfer block size 
  long    f_blocks;   -- total data blocks in file system 
  long    f_bfree;    -- free blocks in fs 
  long    f_bavail;   -- free blocks avail to non-superuser 
  long    f_files;    -- total file nodes in file system 
  long    f_ffree;    -- free file nodes in fs 
  fsid_t  f_fsid;     -- file system id 
  long    f_namelen;  -- maximum length of filenames 
  }
  """
  (tipe, bsize, blocks, bfree, bavail, files, ffree, fsid, namelen, frsize, spare) = (  fsd['f_type'],
                                                                         fsd['f_bsize'],
                                                                         fsd['f_blocks'],
                                                                         fsd['f_bfree'],
                                                                         fsd['f_bavail'],
                                                                         fsd['f_files'],
                                                                         fsd['f_files'],
                                                                         fsd['f_fsid'],
                                                                         fsd['f_namelen'],
                                                                         fsd['f_frsize'],
                                                                         fsd['f_spare'])

  format = '<q<q<q<q<q<q<q<Q<q<q8s'
  result = struct_pack(format, tipe, bsize, blocks, bfree, bavail, files, ffree, fsid, namelen, frsize, spare)
  return result
  

include lind_fs_constants.py

include serialize.repy

include lind_fs_calls.py

include fs_open.repy

include fs_write.repy

include fs_fstatfs.repy

include comp.repy

include fs_access.repy

include fs_read.repy

include fs_fstat.repy

include fs_close.repy

include fs_lseek.repy

include fs_mkdir.repy

include fs_rmdir.repy

include fs_chdir.repy

include fs_link.repy

include fs_unlink.repy

include fs_xstat.repy

include fs_getdents.repy

include sys_getpid.repy

include debug.repy

include unimplemented_syscalls.repy

include dispatcher.repy



def print_times(times):
  print "\nSummary of System Call Execution Times:"
  prefix = ">> "  # prefix which the shell scripts can use to pull out these numbers
  for eachtime in times:
    each = 0
    call = eachtime[each]
    each += 1
    # using the call number, pull the string name out of the function object
    function_name = str(curr_comp()[SYSCALL][call]).split(" ")[1]
    exec_pre = eachtime[each]
    each += 1
    exec_start = eachtime[each]
    each += 1
    exec_post = eachtime[each] 
    each += 1
    exec_stop = eachtime[each] 
    each += 1
    exec_before = eachtime[each] 
    each += 1
    exec_after = eachtime[each] 
    each += 1
    call_args = eachtime[each]
    print prefix, function_name + ", "+ "%f"%(exec_pre) + ", " + "%f"%(exec_start) + ", " + "%f"%(exec_post) + ", " + "%f"%(exec_stop) + ", " + "%f"%(exec_before) + ", " + "%f"%(exec_after) + ", \"" + str(call_args) + "\""



def NaclRPCServer(nacl_instance, comp_num):
  #timer =  mycontext["wallclocktime"]
  #times = []
  while True:
    format = "<i<I<I<i"
    start = 0
    stop = 0
    try:
     # pre = timer()
      message = nacl_instance.recv(1024)
     # start = timer()
    except exceptions.Exception:
      log("[ERROR][RPC] " + "Exception on receive\n")
      break
  
    # log("[info][RPC] " +  "Raw Message: "+ message +"\n")
    header = message[0:16]
    if header == "EOT":
      break
    magic = 0
    call = 0
    frmt_len = 0
    valid = 0
    try:
      [magic, call, frmt_len, valid] = struct_unpack(format, header)
    except Exception, err:
      log("[ERROR][RPC] ", type(err),  ":", err, "\n")

    if magic != -2:
      raise Exception("Protocol Error: Magic number not found. Was expecting -2, got " + str(magic) )
    # We probably dont need this in the future, but for now:
    checksum = magic + call  + frmt_len

    if valid != checksum:
      raise Exception("Protocol Error: Validation number not found. We got " + str(valid) + ", expected " + str(checksum) )

    if frmt_len == 0:
      args = []
    else:
      args_string = message[16+frmt_len+1:]
      message_format = message[16:16+frmt_len]
      # print "message format: ", message_format
      try: 
        trimmed_string = args_string
        # print "Args: ",trimmed_string
        args = struct_unpack(message_format, trimmed_string)
        # print "Parsed Args", args
      except ValueError as e:
        log("Unpacking Error: " + str(e) + "\n")
        log("Message was: " + message_format + "\n")
        log("Args len=" + str(len(trimmed_string)) + "\n")
        log("Args full=" + str(args_string) + "\n")
        log("Args String=" + trimmed_string + "\n")
        call = NOOP_CALL_NUM # continue on with eno_sys
    # before_call = timer()
    mycontext[LOCK].acquire(True)
    mycontext[COMP] = comp_num
    response = dispatch_syscall(call, args)
    mycontext[LOCK].release()
    # after_call = timer()
    if response == None:
      raise Exception()
    # print response
    retcode_buffer = response.make_struct()
    # print retcode_buffer
    try:
      # post = timer()
      got = nacl_instance.send(retcode_buffer,"")
      # stop = timer()
    except:
      log("[info][RPC] " + "Exception on Send. Stopping\n")
      break
    if got == 0:
      log("[ERROR][RPC] " + "failed to send\n")
    # times.append((call, pre ,start, post, stop, before_call, after_call, args))
    
  print "Lind Server ", mycontext[comp_num][PROGRAM], " Shutting Down."
  # print_times(times)


def main():
  code_loc = curr_comp()[PROGRAM]
  nacl = safelyexecutenativecode(code_loc, curr_comp()[CMD_LINE])

  if nacl != None:
    NaclRPCServer(nacl, 1)
  else:
    print "Safe Binary mode must be switched on for this program to work."
    

def setup_testing():
  """ Setup things for the test enviroment.  Remove from prouction version! """
  #check_file_io looks for foo.txt and reads it, so we must create it here.
  print "Warning: adding files for testing."
  f = openfile("foo.txt", True)
  f2 = openfile("foo2.txt", True)
  f.writeat("Hello World", 0)
  f.close()
  f2.close()

def launch_helper(instance, num):
  """save the instance and start the server in a thread."""
  def closure():
    NaclRPCServer(instance, num)
  createthread(closure)
  
def new_compoent():
  """add a new compoent to the system"""
  mycontext[2]={}
  code_loc = "liblind/com2.nexe"
  mycontext[2][PROGRAM] = code_loc
  mycontext[2][CMD_LINE] = []
  setup_dispatcher(2)
  setup_filetable(2)
  setup_component_communication(2)
  nacl = safelyexecutenativecode(code_loc, [])
  
  
  if nacl != None:
    launch_helper(nacl, 2)
  else:
    print "Safe Binary mode must be switched on for this program to work."

def setup_filetable(comp_num):

  _blank_fs_init()

def setup_component_communication(comp_num):
    comp(comp_num)[MBOX] = []

 
def lind_factory():

  setup_dispatcher(1)
  setup_filetable(1)
  setup_component_communication(1)
  mycontext[LOCK] = createlock()
  # are we running the C test program? if so make testing files
  if "glibc_test" in curr_comp()[PROGRAM]:
    setup_testing()

  #if we are running a compoent, launch another one as a test.  
  if "com1" in curr_comp()[PROGRAM]:
    log("starting multi-component test mode")
    mycontext[COMP_MODE] = True
    new_compoent()
  else:
    mycontext[COMP_MODE] = False


def parse_commandline():
  mycontext[COMP] = 1
  mycontext[1] = {}
  curr_comp()[PROGRAM] = callargs[0]
  print curr_comp()[PROGRAM]
  curr_comp()[CMD_LINE] = callargs[1:]

if callfunc == "initialize":
  parse_commandline()
  lind_factory()
  main()
  log("Exiting Lind")
