"""
The Lind OS Server.  This module services system calls coming from glibc
<Author>
  Chris Matthews (cmatthew@cs.uvic.ca)
<Start Date>
  Dececmber 2010
"""

include struct.repy           

# if you comment this include out the line numbers are
# correct for syntax errors.
 

SYSCALL="syscall"               # shortcut to syscall dict items
FILES="FILES"                   # these also make a typo more specific
                                # than a dict lookup error

class Response:
  """ An Response to a RPC request.

  <Purpose>

  This object is responsible sending responses to specific system calls.  It is
  loaded with data, then can build a reply struct which can then be sent back to
  NaCl through an IMC channel.

  The Response can be in one of two states, an Error response (for calls that
  have failed somehow), or a success response. An error response has an error
  code and a message for perror to display. A success has a return code and
  optionally a data string.

  TODO: error message is not yet displayed by perror.
  """
  message = "No error message set"
  data = ""

  def __init__(self, response_type,  is_error, return_code):
    assert isinstance(response_type, str), "response type is not a string"
    self.response_type = response_type
    assert isinstance(is_error, bool), "is error is not a boolean"
    self.is_error = is_error
    
    if isinstance(return_code, str):
      self.return_code =  mycontext["errno.h"][return_code]
    else:
      self.return_code = return_code
    assert isinstance(self.return_code, int), "return code is not a int, or a stirng which mapped to an int"

  def make_struct(self):
    """
    <Purpose>

    Get the representation of this Response in struct format.  A struct is a
    string, which when sent to C can be cast as a struct and used nativly.
    The struct format is iiii123s, wich is:
    struct {
        int message_len;
        int magic_number;
        int is_in_error;
        int return_or_error_code;
        char data_or_message[];
    };

    """
    reply = None
    if self.is_error:
      # message format <is_error, code, message>
      reply = struct_pack("<i<i<i<i" + str(len(self.message)) + "s", len(self.message) + 12, 101010, 1, self.return_code, self.message)
    else:
      # message format <is_error, code, data>
      reply = struct_pack("<i<i<i<i" + str(len(self.data)) + "s", len(self.data) + 12, 101010, 0, self.return_code, self.data)
    return reply

  def __str__(self):
    """Human readable format for debugging"""
    if self.is_error:
      type_str = "Error"
    else:
      type_str = "Success"
    return type_str + " in " + self.response_type + " with code " + str(self.return_code)

def ErrorResponseBuilder(who ,code, message):
  """ Build an error response object.

  <Arguments>
   who: Which portion of the system or system call is making this reply.
   code: Positive error code to return, or string from errno.h to resolve to a number.
   message: A detailed message about the error.
   """
  r = Response(who, True, code)
  r.message = message
  return r

def SuccessResponseBuilder(who, code, data=None):
  """Build an success response object.

  <Arugments>
     who: Which portion of the system or system call is making this reply.
     code: the integer return code to return.
     data: the data this call returns (as a string), if any.
  """
  r =  Response(who, False, code)
  if data!=None:
    r.data = data
  return r


def lind_fs_access(args):
  """
  NAME
       access - check real user's permissions for a file

  SYNOPSIS
       #include <unistd.h>

       int access(const char *pathname, int mode);

   DESCRIPTION
       access() checks whether the calling process can access the file pathname.
       If pathname is a symbolic link, it is dereferenced.

       The mode specifies the accessibility check(s) to be performed, and is
       either the value F_OK, or a mask consisting of the bitwise OR of one or
       file exists and grants read, write, and execute permissions,
       respectively.

       The check is done using the calling process's real UID and GID, rather
       than the effective IDs as is done when actually attempting an operation
       (e.g., open(2)) on the file.  This allows set-user-ID programs to easily
       determine the invoking user's author‚Äê ity.

       If the calling process is privileged (i.e., its real UID is zero), then
       an X_OK check is successful for a regular file if execute permission is
       enabled for any of the file owner, group, or other.

  RETURN VALUE
       On success (all requested permissions granted), zero is returned.  On
       error (at least one bit in mode asked for a permission that is denied, or
       some other error occurred), -1 is returned, and errno is set
       appropriately.

  ERRORS
       access() shall fail if:

       EACCES The requested access would be denied to the file, or search
       permission is denied for one of the directories in the path prefix of
       pathname.  (See also path_resolution(7).)

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling symbolic link.

       ENOTDIR A component used as a directory in pathname is not, in fact, a
              directory.

       EROFS Write permission was requested for a file on a read-only file
       system.

       access() may fail if:

       EFAULT pathname points outside your accessible address space.

       EINVAL mode was incorrectly specified.

       EIO    An I/O error occurred.

       ENOMEM Insufficient kernel memory was available.

       ETXTBSY Write access was requested to an executable which is being
              executed.
  """
  log("Calling Access")
  #TODO(cmatthew): implement basic checking
  return ErrorResponseBuilder("fs_access", "ENOSYS", "access system call is not implemented." )


def lind_fs_open(args):
  """int open(const char *pathname, int flags);
  int open(const char *pathname, int flags, mode_t mode);
  int creat(const char *pathname, mode_t mode);

  Description

  Given a pathname for a file, open() returns a file descriptor, a small,
  non-negative integer for use in subsequent system calls (read(2), write(2),
  lseek(2), fcntl(2), etc.). The file descriptor returned by a successful call
  will be the lowest-numbered file descriptor not currently open for the
  process.  The new file descriptor is set to remain open across an execve(2)
  (i.e., the FD_CLOEXEC file descriptor flag described in fcntl(2) is initially
  disabled). The file offset is set to the beginning of the file (see lseek(2)).

  A call to open() creates a new open file description, an entry in the
  system-wide table of open files. This entry records the file offset and the
  file status flags (modifiable via the fcntl() F_SETFL operation). A file
  descriptor is a reference to one of these entries; this reference is
  unaffected if pathname is subsequently removed or modified to refer to a
  different file. The new open file description is initially not shared with any
  other process, but sharing may arise via fork(2).

  The parameter flags must include one of the following access modes: O_RDONLY,
  O_WRONLY, or O_RDWR. These request opening the file read-only, write-only, or
  read/write, respectively.

  In addition, zero or more file creation flags and file status flags can be
  bitwise-or'd in flags. The file creation flags are O_CREAT, O_EXCL, O_NOCTTY,
  and O_TRUNC. The file status flags are all of the remaining flags listed
  below. The distinction between these two groups of flags is that the file
  status flags can be retrieved and (in some cases) modified using fcntl(2). The
  full list of file creation flags and file status flags is as follows:

  O_APPEND The file is opened in append mode. Before each write(), the file
  offset is positioned at the end of the file, as if with lseek(). O_APPEND may
  lead to corrupted files on NFS file systems if more than one process appends
  data to a file at once. This is because NFS does not support appending to a
  file, so the client kernel has to simulate it, which can't be done without a
  race condition.  O_ASYNC Enable signal-driven I/O: generate a signal (SIGIO by
  default, but this can be changed via fcntl(2)) when input or output becomes
  possible on this file descriptor. This feature is only available for
  terminals, pseudo-terminals, sockets, and (since Linux 2.6) pipes and
  FIFOs. See fcntl(2) for further details.  O_CREAT If the file does not exist
  it will be created. The owner (user ID) of the file is set to the effective
  user ID of the process. The group ownership (group ID) is set either to the
  effective group ID of the process or to the group ID of the parent directory
  (depending on filesystem type and mount options, and the mode of the parent
  directory, see, e.g., the mount options bsdgroups and sysvgroups of the ext2
  filesystem, as described in mount(8)).  O_DIRECT Try to minimize cache effects
  of the I/O to and from this file. In general this will degrade performance,
  but it is useful in special situations, such as when applications do their own
  caching. File I/O is done directly to/from user space buffers. The I/O is
  synchronous, i.e., at the completion of a read(2) or write(2), data is
  guaranteed to have been transferred. Under Linux 2.4 transfer sizes, and the
  alignment of user buffer and file offset must all be multiples of the logical
  block size of the file system. Under Linux 2.6 alignment to 512-byte
  boundaries suffices.  A semantically similar (but deprecated) interface for
  block devices is described in raw(8).

  O_DIRECTORY If pathname is not a directory, cause the open to fail. This flag
  is Linux-specific, and was added in kernel version 2.1.126, to avoid
  denial-of-service problems if opendir(3) is called on a FIFO or tape device,
  but should not be used outside of the implementation of opendir.  O_EXCL When
  used with O_CREAT, if the file already exists it is an error and the open()
  will fail. In this context, a symbolic link exists, regardless of where it
  points to. O_EXCL is broken on NFS file systems; programs which rely on it for
  performing locking tasks will contain a race condition. The solution for
  performing atomic file locking using a lockfile is to create a unique file on
  the same file system (e.g., incorporating hostname and pid), use link(2) to
  make a link to the lockfile. If link() returns 0, the lock is
  successful. Otherwise, use stat(2) on the unique file to check if its link
  count has increased to 2, in which case the lock is also successful.
  O_LARGEFILE (LFS) Allow files whose sizes cannot be represented in an off_t
  (but can be represented in an off64_t) to be opened.  O_NOATIME (Since Linux
  2.6.8) Do not update the file last access time (st_atime in the inode) when
  the file is read(2). This flag is intended for use by indexing or backup
  programs, where its use can significantly reduce the amount of disk
  activity. This flag may not be effective on all filesystems. One example is
  NFS, where the server maintains the access time.  O_NOCTTY If pathname refers
  to a terminal device -- see tty(4) -- it will not become the process's
  controlling terminal even if the process does not have one.  O_NOFOLLOW If
  pathname is a symbolic link, then the open fails. This is a FreeBSD extension,
  which was added to Linux in version 2.1.126. Symbolic links in earlier
  components of the pathname will still be followed.  O_NONBLOCK or O_NDELAY
  When possible, the file is opened in non-blocking mode. Neither the open() nor
  any subsequent operations on the file descriptor which is returned will cause
  the calling process to wait. For the handling of FIFOs (named pipes), see also
  fifo(7). For a discussion of the effect of O_NONBLOCK in conjunction with
  mandatory file locks and with file leases, see fcntl(2).  O_SYNC The file is
  opened for synchronous I/O. Any write()s on the resulting file descriptor will
  block the calling process until the data has been physically written to the
  underlying hardware. But see RESTRICTIONS below.  O_TRUNC If the file already
  exists and is a regular file and the open mode allows writing (i.e., is O_RDWR
  or O_WRONLY) it will be truncated to length 0. If the file is a FIFO or
  terminal device file, the O_TRUNC flag is ignored. Otherwise the effect of
  O_TRUNC is unspecified.  Some of these optional flags can be altered using
  fcntl() after the file has been opened.

  The argument mode specifies the permissions to use in case a new file is
  created. It is modified by the process's umask in the usual way: the
  permissions of the created file are (mode & ~umask). Note that this mode only
  applies to future accesses of the newly created file; the open() call that
  creates a read-only file may well return a read/write file descriptor.

  The following symbolic constants are provided for mode:

  S_IRWXU 00700 user (file owner) has read, write and execute permission S_IRUSR
  00400 user has read permission S_IWUSR 00200 user has write permission S_IXUSR
  00100 user has execute permission S_IRWXG 00070 group has read, write and
  execute permission S_IRGRP 00040 group has read permission S_IWGRP 00020 group
  has write permission S_IXGRP 00010 group has execute permission S_IRWXO 00007
  others have read, write and execute permission S_IROTH 00004 others have read
  permission S_IWOTH 00002 others have write permission S_IXOTH 00001 others
  have execute permission mode must be specified when O_CREAT is in the flags,
  and is ignored otherwise.

  creat() is equivalent to open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.

  Return Value

  open() and creat() return the new file descriptor, or -1 if an error occurred
  (in which case, errno is set appropriately).
  """

  file_name_length = args[2]
  file_name = args[3][0:file_name_length]

  # check old handles, if there, just return that one
  for (name, f) in mycontext[FILES]:
    if name == file_name:
      return SuccessResponseBuilder("fs_open", mycontext[FILES].index((name,f)) )
  try:
    file_name = file_name.split("/")[-1]

    log("[info][syscall] Calling Open: " + file_name + "\n")
    f = openfile(file_name, False)
    mycontext[FILES].append((file_name,f))
  except FileNotFoundError,e:
    message = "Could not find file: " + file_name +"\n" +str(e) 
    log( message )
    return ErrorResponseBuilder("fs_open", "ENOENT", message )
  file_handle = mycontext[FILES].index((file_name, f))
  return SuccessResponseBuilder("fs_open", file_handle)


def lind_err_enosys(args):
  return  ErrorResponseBuilder("ENOSYS", "This system call is not implemented yet or disabled in Lind.")


def lind_sys_getpid(args):
  log("[info][syscall] Calling GetPID")
  # For now we dont want processes to know they are different than each other
  # maybe this could be a lind specific counter in the future?
  # what is the impact of doing this?
  DEFAULT_PID = 1000
  return SuccessResponseBuilder("sys_getpid", DEFAULT_PID)


def lind_debug_trace(args):
  print "[info][Trace] " + str(args[0])
  return SuccessResponseBuilder("debug_trace", 0)


def dispatch_syscall(call, args):
  try:
    syscall_response = mycontext[SYSCALL][call](args)
  except KeyError,e:
    log("[ERROR][dispatch] Failed to look up " + str(call) + str(e) + "\n")
    syscall_response =  ErrorResponseBuilder("ENOSYS", "The system call is not in the system call table. Call="+str(call))
  
  assert isinstance(syscall_response, Response), "Returning something that is not a response. Check system calls: " + str(type(syscall_response)) + " form " + str(call)
  
  return syscall_response


def NaclRPCServer(nacl_instance):
  while True:
    format = "<i<I<I<i"
    try:
      message = nacl_instance.recv(1024)
    except exceptions.Exception:
      log("[ERROR][RPC] " + "Exception on receive\n")
      break
    # log("[info][RPC] " +  "Raw Message: "+ message +"\n")
    header = message[0:16]
    if header == "EOT":
      break
    magic = 0
    call = 0
    frmt_len = 0
    valid = 0
    try:
      [magic, call, frmt_len, valid] = struct_unpack(format, header)
    except Exception, err:
      log("[ERROR][RPC] " + str(type(err))+ ":"+str(err)+"\n")

    if magic != -2:
      raise Exception("Protocol Error: Magic number not found. Was expecting -2, got " + str(magic) )
    # We probably dont need this in the future, but for now:
    checksum = magic + call  + frmt_len

    if valid != checksum:
      raise Exception("Protocol Error: Validation number not found. We got " + str(valid) + ", expected " + str(checksum) )

    if frmt_len == 0:
      args = []
    else:
      args_string = message[16+frmt_len:]
      message_format = message[16:16+frmt_len]
      # print "message format: ", message_format
      args = struct_unpack(message_format, args_string[:-1])

    response = dispatch_syscall(call, args)
    if response == None:
      raise Exception()
    print response
    retcode_buffer = response.make_struct()
    # print retcode_buffer
    try:
      got = nacl_instance.send(retcode_buffer,"")
    except:
      log("[info][RPC] " + "Exception on Send. Stopping\n")
      break
    if got == 0:
      log("[ERROR][RPC] " + "failed to send\n")

  print "Lind Server Shutting Down."

def main():
  code_loc = "/home/cmatthew/lind/native_client/scons-out/nacl-x86-64-glibc/staging/glibc_test.nexe"
  nacl = safelyexecutenativecode(code_loc, ["1","2"])


  if nacl != None:
    NaclRPCServer(nacl)
  else:
    print "Safe Binary mode must be switched on for this program to work."


"""
#define NACL_sys_null                    1

#define NACL_sys_open                   10
#define NACL_sys_close                  11
#define NACL_sys_read                   12
#define NACL_sys_write                  13
#define NACL_sys_lseek                  14
#define NACL_sys_ioctl                  15
#define NACL_sys_stat                   16
#define NACL_sys_fstat                  17
#define NACL_sys_chmod                  18
/* no fchmod emulation on windows */

#define NACL_sys_sysbrk                 20
#define NACL_sys_mmap                   21
#define NACL_sys_munmap                 22

#define NACL_sys_getdents               23

#define NACL_sys_exit                   30
#define NACL_sys_getpid                 31
#define NACL_sys_sched_yield            32
#define NACL_sys_sysconf                33

#define NACL_sys_gettimeofday           40
#define NACL_sys_clock                  41
#define NACL_sys_nanosleep              42

#define NACL_sys_multimedia_init        50
#define NACL_sys_multimedia_shutdown    51
#define NACL_sys_video_init             52
#define NACL_sys_video_shutdown         53
#define NACL_sys_video_update           54
#define NACL_sys_video_poll_event       55
#define NACL_sys_audio_init             56
#define NACL_sys_audio_shutdown         57
#define NACL_sys_audio_stream           58

#define NACL_sys_imc_makeboundsock      60
#define NACL_sys_imc_accept             61
#define NACL_sys_imc_connect            62
#define NACL_sys_imc_sendmsg            63
#define NACL_sys_imc_recvmsg            64
#define NACL_sys_imc_mem_obj_create     65
#define NACL_sys_imc_socketpair         66

#define NACL_sys_mutex_create           70
#define NACL_sys_mutex_lock             71
#define NACL_sys_mutex_trylock          72
#define NACL_sys_mutex_unlock           73
#define NACL_sys_cond_create            74
#define NACL_sys_cond_wait              75
#define NACL_sys_cond_signal            76
#define NACL_sys_cond_broadcast         77
#define NACL_sys_cond_timed_wait_abs    79

#define NACL_sys_thread_create          80
#define NACL_sys_thread_exit            81
#define NACL_sys_tls_init               82
#define NACL_sys_thread_nice            83
#define NACL_sys_tls_get                84

#define NACL_sys_srpc_get_fd            90

#define NACL_sys_sem_create             100
#define NACL_sys_sem_wait               101
#define NACL_sys_sem_post               102
#define NACL_sys_sem_get_value          103
 
#define NACL_sys_dyncode_copy           104

"""



def setup_testing():
  """ Setup things for the test enviroment.  Remove from prouction version! """
  #check_file_io looks for foo.txt and reads it, so we must create it here.
  f = openfile("foo.txt", True)
  f.writeat("Hello World", 0)
  f.close()



def lind_factory():
  # map a systemcall number to a particular function
  mycontext[SYSCALL] = {1:lind_debug_trace, 
                        10:lind_fs_open,
                        12:lind_fs_read,
                        3:lind_err_enosys, 
                        31:lind_sys_getpid}
  
  #setup error codes
  mycontext["errno.h"] = {'ENOENT':2,  'ENOSYS':38 }

  #table of file handles
  mycontext["FILES"] = []

  handle_offset = 10            # The amount by which we offset fileandles (so we
                                # dont clobber stdin out err and system file handles

  for i in range(0, handle_offset):
    mycontext["FILES"].append(("",0))

  setup_testing()

if callfunc == "initialize":
  print "Welcome to Lind"
  lind_factory()
  main()
