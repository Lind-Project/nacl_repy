"""
The Lind OS Server.  This module services system calls coming from glibc
<Author>
  Chris Matthews (cmatthew@cs.uvic.ca)
<Start Date>
  Dececmber 2010
"""



include struct.repy
 

SYSCALL="syscall"
FILES="FILES"

class Response:
  message = "No error message set"
  data = ""

  def __init__(self, response_type,  is_error, return_code):
    assert isinstance(response_type, str), "response type is not a string"
    self.response_type = response_type
    assert isinstance(is_error, bool), "is error is not a boolean"
    self.is_error = is_error
    
    if isinstance(return_code, str):
      self.return_code =  mycontext["errno.h"][return_code]
    else:
      self.return_code = return_code
    assert isinstance(self.return_code, int), "return code is not a int, or a stirng which mapped to an int"
  def make_struct(self):
    reply = None
    if self.is_error:
      reply = struct_pack("<i<i" + str(len(self.message))+"s", 1, self.return_code, self.message)
    else:
      reply = struct_pack("<i<i" + str(len(self.data)) + "s", 0, self.return_code, self.data)
    return reply

  def __str__(self):
    if self.is_error:
      type_str = "Error"
    else:
      type_str = "Success"
    return type_str + " in " + self.response_type + " with code " + str(self.return_code)

def ErrorResponseBuilder(who ,code, message):
  r = Response(who, True, code)
  r.message = message
  return r

def SuccessResponseBuilder(who, code, data=None):
  r =  Response(who, False, code)
  if data!=None:
    r.data = data
  return r


def lind_fs_access(args):
  """
  NAME
       access - check real user's permissions for a file

  SYNOPSIS
       #include <unistd.h>

       int access(const char *pathname, int mode);

   DESCRIPTION
       access() checks whether the calling process can access the file pathname.
       If pathname is a symbolic link, it is dereferenced.

       The  mode specifies the accessibility check(s) to be performed, and is
       either the value F_OK, or a mask consisting of the bitwise OR of one or
       file exists and grants read, write, and execute permissions, respectively.

       The check is done using the calling process's real UID and GID, rather
       than the effective IDs as is done when actually attempting an operation
       (e.g., open(2)) on the file.  This allows set-user-ID programs to easily
       determine the invoking user's  author‚Äê
       ity.

       If the calling process is privileged (i.e., its real UID is zero), then
       an X_OK check is successful for a regular file if execute permission is
       enabled for any of the file owner, group, or other.

  RETURN VALUE
       On success (all requested permissions granted), zero is returned.  On
       error (at least one bit in mode asked for a permission that is denied,
       or some other error occurred), -1 is returned, and errno is set appropriately.

  ERRORS
       access() shall fail if:

       EACCES The requested access would be denied to the file, or search
       permission is denied for one of the directories in the path prefix of
       pathname.  (See also path_resolution(7).)

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ENAMETOOLONG pathname is too long.

       ENOENT A component of pathname does not exist or is a dangling symbolic link.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory.

       EROFS  Write permission was requested for a file on a read-only file system.

       access() may fail if:

       EFAULT pathname points outside your accessible address space.

       EINVAL mode was incorrectly specified.

       EIO    An I/O error occurred.

       ENOMEM Insufficient kernel memory was available.

       ETXTBSY
              Write access was requested to an executable which is being executed.
  """
  log("Calling Access")
  #TODO(cmatthew): implement basic checking
  return -3


def lind_fs_open(args):

  file_name_length = args[2]
  file_name = args[3][0:file_name_length]

  # check old handles, if there, just return that one
  for (name, f) in mycontext[FILES]:
    if name == file_name:
      return mycontext[FILES].index((name,f))
  try:
    file_name = file_name.split("/")[-1]

    log("[info][syscall] Calling Open: " + file_name + "\n")
    f = openfile(file_name, False)
    mycontext[FILES].append((file_name,f))
  except FileNotFoundError,e:
    message = "Could not find file: " + file_name +"\n" +str(e) 
    log( message )
    return ErrorResponseBuilder("fs_open", "ENOENT", message )
  file_handle = mycontext[FILES].index((file_name, f))
  return SuccessResponseBuilder("fs_open", file_handle)

def lind_err_enosys(args):
  return  ErrorResponseBuilder("ENOSYS", "This system call is not implemented yet or disabled in Lind.")


def lind_sys_getpid(args):
  log("[info][syscall] Calling GetPID")
  # For now we dont want processes to know they are different than each other
  # maybe this could be a lind specific counter in the future?
  # what is the impact of doing this?
  DEFAULT_PID = 1000
  return SuccessResponseBuilder("sys_getpid", DEFAULT_PID)


def lind_debug_trace(args):
  print "[info][Trace] " + str(args[0])
  return SuccessResponseBuilder("debug_trace", 0)


def dispatch_syscall(call, args):
  try:
    syscall_response = mycontext[SYSCALL][call](args)
  except KeyError,e:
    log("[ERROR][dispatch] Failed to look up " + str(call) + str(e) + "\n")
    syscall_response =  ErrorResponseBuilder("ENOSYS", "The system call is not in the system call table. Call="+str(call))
  
  assert isinstance(syscall_response, Response)
  
  return syscall_response


def NaclRPCServer(nacl_instance):
  while True:
    format = "<i<I<I<i"
    try:
      message = nacl_instance.recv(1024)
    except exceptions.Exception:
      log("[ERROR][RPC] " + "Exception on receive\n")
      break
    # log("[info][RPC] " +  "Raw Message: "+ message +"\n")
    header = message[0:16]
    if header == "EOT":
      break
    magic = 0
    call = 0
    frmt_len = 0
    valid = 0
    try:
      [magic, call, frmt_len, valid] = struct_unpack(format, header)
    except Exception, err:
      log("[ERROR][RPC] " + str(type(err))+ ":"+str(err)+"\n")

    if magic != -2:
      raise Exception("Protocol Error: Magic number not found. Was expecting -2, got " + str(magic) )
    # We probably dont need this in the future, but for now:
    checksum = magic + call  + frmt_len

    if valid != checksum:
      raise Exception("Protocol Error: Validation number not found. We got " + str(valid) + ", expected " + str(checksum) )

    if frmt_len == 0:
      args = []
    else:
      args_string = message[16+frmt_len:]
      message_format = message[16:16+frmt_len]
      # print "message format: ", message_format
      args = struct_unpack(message_format, args_string[:-1])

    response = dispatch_syscall(call, args)
    if response == None:
      raise Exception()
    print response
    retcode_buffer = response.make_struct()
    print retcode_buffer
    try:
      got = nacl_instance.send(retcode_buffer,"")
    except:
      log("[info][RPC] " + "Exception on Send. Stopping\n")
      break
    if got == 0:
      log("[ERROR][RPC] " + "failed to send\n")

  print "Lind Server Shutting Down."

def main():
  code_loc = "/home/cmatthew/lind/native_client/scons-out/nacl-x86-64-glibc/staging/glibc_test.nexe"
  nacl = safelyexecutenativecode(code_loc, ["1","2"])


  if nacl != None:
    NaclRPCServer(nacl)
  else:
    print "Safe Binary mode must be switched on for this program to work."


"""
#define NACL_sys_null                    1

#define NACL_sys_open                   10
#define NACL_sys_close                  11
#define NACL_sys_read                   12
#define NACL_sys_write                  13
#define NACL_sys_lseek                  14
#define NACL_sys_ioctl                  15
#define NACL_sys_stat                   16
#define NACL_sys_fstat                  17
#define NACL_sys_chmod                  18
/* no fchmod emulation on windows */

#define NACL_sys_sysbrk                 20
#define NACL_sys_mmap                   21
#define NACL_sys_munmap                 22

#define NACL_sys_getdents               23

#define NACL_sys_exit                   30
#define NACL_sys_getpid                 31
#define NACL_sys_sched_yield            32
#define NACL_sys_sysconf                33

#define NACL_sys_gettimeofday           40
#define NACL_sys_clock                  41
#define NACL_sys_nanosleep              42

#define NACL_sys_multimedia_init        50
#define NACL_sys_multimedia_shutdown    51
#define NACL_sys_video_init             52
#define NACL_sys_video_shutdown         53
#define NACL_sys_video_update           54
#define NACL_sys_video_poll_event       55
#define NACL_sys_audio_init             56
#define NACL_sys_audio_shutdown         57
#define NACL_sys_audio_stream           58

#define NACL_sys_imc_makeboundsock      60
#define NACL_sys_imc_accept             61
#define NACL_sys_imc_connect            62
#define NACL_sys_imc_sendmsg            63
#define NACL_sys_imc_recvmsg            64
#define NACL_sys_imc_mem_obj_create     65
#define NACL_sys_imc_socketpair         66

#define NACL_sys_mutex_create           70
#define NACL_sys_mutex_lock             71
#define NACL_sys_mutex_trylock          72
#define NACL_sys_mutex_unlock           73
#define NACL_sys_cond_create            74
#define NACL_sys_cond_wait              75
#define NACL_sys_cond_signal            76
#define NACL_sys_cond_broadcast         77
#define NACL_sys_cond_timed_wait_abs    79

#define NACL_sys_thread_create          80
#define NACL_sys_thread_exit            81
#define NACL_sys_tls_init               82
#define NACL_sys_thread_nice            83
#define NACL_sys_tls_get                84

#define NACL_sys_srpc_get_fd            90

#define NACL_sys_sem_create             100
#define NACL_sys_sem_wait               101
#define NACL_sys_sem_post               102
#define NACL_sys_sem_get_value          103
 
#define NACL_sys_dyncode_copy           104

"""



def setup_testing():
  """ Setup things for the test enviroment.  Remove from prouction version! """
  #check_file_io looks for foo.txt and reads it, so we must create it here.
  f = openfile("foo.txt", True)
  f.writeat("Hello World", 0)
  f.close()



def lind_factory():
  # map a systemcall number to a particular function
  mycontext[SYSCALL] = {1:lind_debug_trace, 
                        10:lind_fs_open, 
                        3:lind_err_enosys, 
                        31:lind_sys_getpid}
  
  #setup error codes
  mycontext["errno.h"] = {'ENOENT':2,  'ENOSYS':38 }

  #table of file handles
  mycontext["FILES"] = []
  setup_testing()

if callfunc == "initialize":
  lind_factory()
  main()
